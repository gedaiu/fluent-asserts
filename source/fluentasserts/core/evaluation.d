/// Evaluation structures for fluent-asserts.
/// Provides the core data types for capturing and comparing values during assertions.
module fluentasserts.core.evaluation;

import std.datetime;
import std.traits;
import std.conv;
import std.range;
import std.array;
import std.algorithm : map, move, sort;

import core.memory : GC;

import fluentasserts.core.memory : getNonGCMemory;
import fluentasserts.results.serializers;
import fluentasserts.results.source : SourceResult;
import fluentasserts.results.message : Message, ResultGlyphs;
import fluentasserts.results.asserts : AssertResult;
import fluentasserts.core.base : TestException;
import fluentasserts.results.printer : ResultPrinter, StringResultPrinter;
import fluentasserts.results.serializers : SerializerRegistry;
import fluentasserts.core.memory;

/// Holds the result of evaluating a single value.
/// Captures the value itself, any exceptions thrown, timing information,
/// and serialized representations for display and comparison.
struct ValueEvaluation {
  /// The exception thrown during evaluation
  Throwable throwable;

  /// Time needed to evaluate the value
  Duration duration;

  /// Garbage Collector memory used during evaluation (in bytes)
  size_t gcMemoryUsed;

  /// Non Garbage Collector memory used during evaluation (in bytes)
  size_t nonGCMemoryUsed;

  /// Serialized value as string
  HeapString strValue;

  /// Proxy object holding the evaluated value to help doing better comparisions
  HeapEquableValue proxyValue;

  /// Human readable value
  HeapString niceValue;

  /// The name of the type before it was converted to string (using TypeNameList for @nogc compatibility)
  TypeNameList typeNames;

  /// Other info about the value (using HeapMap for @nogc compatibility)
  HeapMap meta;

  /// The file name containing the evaluated value
  HeapString fileName;

  /// The line number of the evaluated value
  size_t line;

  /// a custom text to be prepended to the value
  HeapString prependText;

  /// Object reference for opEquals comparison (non-@nogc contexts only)
  Object objectRef;

  /// Disable postblit - use copy constructor instead
  @disable this(this);

  /// Copy constructor - creates a deep copy from the source.
  this(ref return scope const ValueEvaluation rhs) @trusted nothrow {
    throwable = cast(Throwable) rhs.throwable;
    duration = rhs.duration;
    gcMemoryUsed = rhs.gcMemoryUsed;
    nonGCMemoryUsed = rhs.nonGCMemoryUsed;
    strValue = rhs.strValue;
    proxyValue = rhs.proxyValue; // Use HeapEquableValue's copy constructor
    niceValue = rhs.niceValue;
    typeNames = rhs.typeNames;
    meta = rhs.meta;
    fileName = rhs.fileName;
    line = rhs.line;
    prependText = rhs.prependText;
    objectRef = cast(Object) rhs.objectRef;
  }

  /// Assignment operator - creates a deep copy from the source.
  void opAssign(ref const ValueEvaluation rhs) @trusted nothrow {
    throwable = cast(Throwable) rhs.throwable;
    duration = rhs.duration;
    gcMemoryUsed = rhs.gcMemoryUsed;
    nonGCMemoryUsed = rhs.nonGCMemoryUsed;
    strValue = rhs.strValue;
    proxyValue = rhs.proxyValue;
    niceValue = rhs.niceValue;
    typeNames = rhs.typeNames;
    meta = rhs.meta;
    fileName = rhs.fileName;
    line = rhs.line;
    prependText = rhs.prependText;
    objectRef = cast(Object) rhs.objectRef;
  }

  /// Returns true if this ValueEvaluation's HeapString fields are valid.
  bool isValid() @trusted nothrow @nogc const {
    return strValue.isValid() && niceValue.isValid();
  }

  /// Returns the primary type name of the evaluated value.
  const(char)[] typeName() @safe nothrow @nogc {
    if (typeNames.length == 0) {
      return "unknown";
    }
    return typeNames[0][];
  }
}

/// Holds the complete state of an assertion evaluation.
/// Contains both the actual and expected values, operation metadata,
/// source location, and the assertion result.
struct Evaluation {
  /// The id of the current evaluation
  size_t id;

  /// The value that will be validated
  ValueEvaluation currentValue;

  /// The expected value that we will use to perform the comparison
  ValueEvaluation expectedValue;

  /// The operation names (stored as array, joined on access)
  private {
    HeapString[8] _operationNames;
    size_t _operationCount;
  }

  /// True if the operation result needs to be negated to have a successful result
  bool isNegated;

  /// Source location data stored as struct
  SourceResult source;

  /// The throwable generated by the evaluation
  Throwable throwable;

  /// True when the evaluation is done
  bool isEvaluated;

  /// Result of the assertion stored as struct
  AssertResult result;

  /// Disable postblit - use copy constructor instead
  @disable this(this);

  /// Copy constructor - creates a deep copy from the source.
  this(ref return scope const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Assignment operator - creates a deep copy from the source.
  void opAssign(ref const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Returns the operation name by joining stored parts with "."
  string operationName() nothrow @safe {
    if (_operationCount == 0) {
      return "";
    }

    if (_operationCount == 1) {
      return _operationNames[0][].idup;
    }

    Appender!string result;
    foreach (i; 0 .. _operationCount) {
      if (i > 0) result.put(".");
      result.put(_operationNames[i][]);
    }

    return result[];
  }

  /// Adds an operation name to the chain
  void addOperationName(string name) nothrow @safe @nogc {
    if (_operationCount < _operationNames.length) {
      auto heapName = HeapString.create(name.length);
      heapName.put(name);
      _operationNames[_operationCount++] = heapName;
    }
  }

  /// Convenience accessors for backwards compatibility
  string sourceFile() nothrow @safe @nogc { return source.file; }
  size_t sourceLine() nothrow @safe @nogc { return source.line; }

  /// Checks if there is an assertion result with content.
  /// Returns: true if the result has expected/actual values, diff, or extra/missing items.
  bool hasResult() nothrow @safe @nogc {
    return result.hasContent();
  }

  /// Prints the assertion result using the provided printer.
  /// Params:
  ///   printer = The ResultPrinter to use for output formatting
  void printResult(ResultPrinter printer) @safe nothrow {
    if(!isEvaluated) {
      printer.primary("Evaluation not completed.");
      return;
    }

    if(!result.hasContent()) {
      printer.primary("Successful result.");
      return;
    }

    printer.info("ASSERTION FAILED: ");

    foreach(ref message; result.messages) {
      printer.print(message);
    }

    printer.newLine;
    printer.info("OPERATION: ");

    if(isNegated) {
      printer.primary("not ");
    }

    printer.primary(operationName);
    printer.newLine;
    printer.newLine;

    printer.info("  ACTUAL: ");
    printer.primary("<");
    printer.primary(currentValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.actual[].idup);
    printer.newLine;

    printer.info("EXPECTED: ");
    printer.primary("<");
    printer.primary(expectedValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.expected[].idup);
    printer.newLine;

    source.print(printer);
  }

  /// Converts the evaluation to a formatted string for display.
  /// Returns: A string representation of the evaluation result.
  string toString() @safe nothrow {
    import std.string : format;

    auto printer = new StringResultPrinter();
    printResult(printer);
    return printer.toString();
  }
}

/// Result of evaluating a value, containing both the value and its evaluation metadata.
/// Replaces Tuple to avoid deprecation warnings with copy constructors.
struct EvaluationResult(T) {
  import std.traits : Unqual;

  Unqual!T value;
  ValueEvaluation evaluation;

  /// Disable postblit - use copy constructor instead
  @disable this(this);

  /// Copy constructor - creates a deep copy from the source.
  this(ref return scope const EvaluationResult rhs) @trusted nothrow {
    value = cast(Unqual!T) rhs.value;
    evaluation = rhs.evaluation; // Uses ValueEvaluation's copy constructor
  }

  void opAssign(ref const EvaluationResult rhs) @trusted nothrow {
    value = cast(Unqual!T) rhs.value;
    evaluation = rhs.evaluation;
  }
}

/// Evaluates a lazy input range value and captures the result.
/// Converts the range to an array and delegates to the primary evaluate function.
/// Params:
///   testData = The lazy value to evaluate
///   file = Source file (auto-captured)
///   line = Source line (auto-captured)
///   prependText = Optional text to prepend to the value display
/// Returns: An EvaluationResult containing the evaluated value and its ValueEvaluation.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isInputRange!T && !isArray!T && !isAssociativeArray!T) {
  return evaluate(testData.array, file, line, prependText);
}

/// Populates a ValueEvaluation with common fields.
void populateEvaluation(T)(
  ref ValueEvaluation eval,
  T value,
  Duration duration,
  size_t gcMemoryUsed,
  size_t nonGCMemoryUsed,
  Throwable throwable,
  string file,
  size_t line,
  string prependText
) @trusted {
  auto serializedValue = SerializerRegistry.instance.serialize(value);
  auto niceValueStr = SerializerRegistry.instance.niceValue(value);

  eval.throwable = throwable;
  eval.duration = duration;
  eval.gcMemoryUsed = gcMemoryUsed;
  eval.nonGCMemoryUsed = nonGCMemoryUsed;
  eval.strValue = toHeapString(serializedValue);
  eval.proxyValue = equableValue(value, niceValueStr);
  eval.niceValue = toHeapString(niceValueStr);
  eval.typeNames = extractTypes!T;
  eval.fileName = toHeapString(file);
  eval.line = line;
  eval.prependText = toHeapString(prependText);

  static if (is(T == class)) {
    eval.objectRef = cast(Object) value;
  }
}

/// Measures memory usage of a callable value.
/// Returns: tuple of (gcMemoryUsed, nonGCMemoryUsed, newBeginTime)
auto measureCallable(T)(T value, SysTime begin) @trusted {
  struct MeasureResult {
    size_t gcMemoryUsed;
    size_t nonGCMemoryUsed;
    SysTime newBegin;
  }

  MeasureResult r;
  r.newBegin = begin;

  static if (isCallable!T) {
    if (value is null) {
      return r;
    }

    r.newBegin = Clock.currTime;
    r.nonGCMemoryUsed = getNonGCMemory();
    auto gcBefore = GC.allocatedInCurrentThread();
    cast(void) value();
    r.gcMemoryUsed = GC.allocatedInCurrentThread() - gcBefore;
    r.nonGCMemoryUsed = getNonGCMemory() - r.nonGCMemoryUsed;
  }

  return r;
}

/// Evaluates a lazy value and captures the result along with timing and exception info.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(!isInputRange!T || isArray!T || isAssociativeArray!T) {
  GC.collect();
  GC.minimize();
  GC.disable();
  scope(exit) GC.enable();

  auto begin = Clock.currTime;
  alias Result = EvaluationResult!T;

  try {
    auto value = testData;
    auto measured = measureCallable(value, begin);

    Result result;
    result.value = value;
    populateEvaluation(result.evaluation, value, Clock.currTime - measured.newBegin, measured.gcMemoryUsed, measured.nonGCMemoryUsed, null, file, line, prependText);
    return move(result);
  } catch (Throwable t) {
    T resultValue;
    static if (isCallable!T) {
      resultValue = testData;
    }

    Result result;
    result.value = resultValue;
    populateEvaluation(result.evaluation, resultValue, Clock.currTime - begin, 0, 0, t, file, line, prependText);
    return move(result);
  }
}

version(unittest) {
  import fluentasserts.core.lifecycle;
}

@("evaluate captures an exception from a lazy value")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  int value() {
    throw new Exception("message");
  }

  auto result = evaluate(value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

@("evaluate captures an exception from a callable")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  void value() {
    throw new Exception("message");
  }

  auto result = evaluate(&value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

/// Extracts the type names for a non-array, non-associative-array type.
/// For classes, includes base classes and implemented interfaces.
/// Params:
///   T = The type to extract names from
/// Returns: A TypeNameList of fully qualified type names.
TypeNameList extractTypes(T)() if((!isArray!T && !isAssociativeArray!T) || isSomeString!T) {
  TypeNameList types;

  types.put(unqualString!T);

  static if(is(T == class)) {
    static foreach(Type; BaseClassesTuple!T) {
      types.put(unqualString!Type);
    }
  }

  static if(is(T == interface) || is(T == class)) {
    static foreach(Type; InterfacesTuple!T) {
      types.put(unqualString!Type);
    }
  }

  return types;
}

/// Extracts the type names for an array type.
/// Appends "[]" to each element type name.
/// Params:
///   T = The array type
///   U = The element type
/// Returns: A TypeNameList of type names with "[]" suffix.
TypeNameList extractTypes(T: U[], U)() if(isArray!T && !isSomeString!T) {
  auto elementTypes = extractTypes!(U);
  TypeNameList types;

  foreach (i; 0 .. elementTypes.length) {
    auto name = elementTypes[i][] ~ "[]";
    types.put(name);
  }

  return types;
}

/// Extracts the type names for an associative array type.
/// Formats as "ValueType[KeyType]".
/// Params:
///   T = The associative array type
///   U = The value type
///   K = The key type
/// Returns: A TypeNameList of type names in associative array format.
TypeNameList extractTypes(T: U[K], U, K)() {
  string k = unqualString!(K);
  auto valueTypes = extractTypes!(U);
  TypeNameList types;

  foreach (i; 0 .. valueTypes.length) {
    auto name = valueTypes[i][] ~ "[" ~ k ~ "]";
    types.put(name);
  }

  return types;
}

@("extractTypes returns [string] for string")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto result = extractTypes!string;
  assert(result.length == 1, "Expected length 1");
  assert(result[0][] == "string", "Expected \"string\"");
}

@("extractTypes returns [string[]] for string[]")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto result = extractTypes!(string[]);
  assert(result.length == 1, "Expected length 1");
  assert(result[0][] == "string[]", "Expected \"string[]\"");
}

@("extractTypes returns [string[string]] for string[string]")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto result = extractTypes!(string[string]);
  assert(result.length == 1, "Expected length 1");
  assert(result[0][] == "string[string]", "Expected \"string[string]\"");
}

version(unittest) {
  interface ExtractTypesTestInterface {}
  class ExtractTypesTestClass : ExtractTypesTestInterface {}
}

@("extractTypes returns all types of a class")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  auto result = extractTypes!(ExtractTypesTestClass[]);

  assert(result[0][] == "fluentasserts.core.evaluation.ExtractTypesTestClass[]", `Expected: "fluentasserts.core.evaluation.ExtractTypesTestClass[]"`);
  assert(result[1][] == "object.Object[]", `Expected: "object.Object[]"`);
  assert(result[2][] == "fluentasserts.core.evaluation.ExtractTypesTestInterface[]", `Expected: "fluentasserts.core.evaluation.ExtractTypesTestInterface[]"`);
}

/// A proxy interface for comparing values of different types.
/// Wraps native values to enable equality and ordering comparisons
/// without knowing the concrete types at compile time.
interface EquableValue {
    /// Checks if this value equals another EquableValue.
    bool isEqualTo(EquableValue value) @safe nothrow @nogc;

    /// Checks if this value is less than another EquableValue.
    bool isLessThan(EquableValue value) @safe nothrow @nogc;

    /// Converts this value to an array of EquableValues.
    EquableValue[] toArray() @safe nothrow;

    /// Returns a string representation of this value.
    string toString() @safe nothrow @nogc;

    /// Returns a generalized version of this value for cross-type comparison.
    EquableValue generalize() @safe nothrow @nogc;

    /// Returns the serialized string representation.
    string getSerialized() @safe nothrow @nogc;

    /// Returns the underlying value as Object if it's a class, null otherwise.
    Object getObjectValue() @trusted nothrow @nogc;
}

/// Wraps a value into a HeapEquableValue for comparison operations.
/// Automatically selects the appropriate kind based on the value type.
/// Params:
///   value = The value to wrap
///   serialized = The serialized string representation of the value
/// Returns: A HeapEquableValue wrapping the given value.
HeapEquableValue equableValue(T)(T value, string serialized) {
  static if(is(T == void[])) {
    // Special case for void[] - can't iterate over it
    return HeapEquableValue.createArray(serialized);
  } else static if(isArray!T && !isSomeString!T) {
    auto result = HeapEquableValue.createArray(serialized);
    foreach(ref elem; value) {
      auto elemSerialized = SerializerRegistry.instance.niceValue(elem);
      result.addElement(equableValue(elem, elemSerialized));
    }
    return result;
  } else static if(isInputRange!T && !isSomeString!T) {
    auto arr = value.array;
    auto result = HeapEquableValue.createArray(serialized);
    foreach(ref elem; arr) {
      auto elemSerialized = SerializerRegistry.instance.niceValue(elem);
      result.addElement(equableValue(elem, elemSerialized));
    }
    return result;
  } else static if(isAssociativeArray!T) {
    auto result = HeapEquableValue.createAssocArray(serialized);
    auto sortedKeys = value.keys.sort;
    foreach(key; sortedKeys) {
      auto keyStr = SerializerRegistry.instance.niceValue(key);
      auto valStr = SerializerRegistry.instance.niceValue(value[key]);
      auto entryStr = keyStr ~ ": " ~ valStr;
      result.addElement(HeapEquableValue.createScalar(entryStr));
    }
    return result;
  } else static if(__traits(hasMember, T, "byValue") && !__traits(hasMember, T, "byKeyValue")) {
    // Objects with byValue (but not byKeyValue, which is for assoc arrays) return array of values
    if (value is null) {
      return HeapEquableValue.createScalar(serialized);
    }
    auto result = HeapEquableValue.createArray(serialized);
    try {
      foreach(elem; value.byValue) {
        auto elemSerialized = SerializerRegistry.instance.niceValue(elem);
        result.addElement(equableValue(elem, elemSerialized));
      }
    } catch (Exception) {
      return HeapEquableValue.createScalar(serialized);
    }
    return result;
  } else {
    return HeapEquableValue.createScalar(serialized);
  }
}

/// An EquableValue wrapper for scalar and object types.
/// Provides equality and ordering comparisons for non-collection values.
class ObjectEquable(T) : EquableValue {
  private T value;
  private string serialized;

  this(T value, string serialized) @trusted nothrow {
    this.value = value;
    this.serialized = serialized;
  }

  bool isEqualTo(EquableValue otherEquable) @trusted nothrow @nogc {
    auto other = cast(ObjectEquable) otherEquable;

    if (other !is null) {
      return compareWithSameType(other);
    }

    return compareWithDifferentType(otherEquable);
  }

  private bool compareWithSameType(ObjectEquable other) @trusted nothrow @nogc {
    static if (is(T == class)) {
      return compareClassValues(value, other.value, serialized, other.serialized);
    } else static if (__traits(compiles, value == other.value)) {
      return value == other.value;
    } else {
      return serialized == other.serialized;
    }
  }

  private bool compareWithDifferentType(EquableValue otherEquable) @trusted nothrow @nogc {
    static if (is(T == class) && __traits(compiles, () nothrow @nogc { T a; if (a !is null) a.opEquals(cast(Object) null); })) {
      return compareClassWithObject(value, otherEquable.getObjectValue());
    } else {
      return serialized == otherEquable.getSerialized;
    }
  }

  private static bool compareClassValues(T a, T b, string serializedA, string serializedB) @trusted nothrow @nogc {
    static if (__traits(compiles, () nothrow @nogc { T x; if (x !is null) x.opEquals(x); })) {
      if (a is null) {
        return b is null;
      }
      if (b is null) {
        return false;
      }
      return a.opEquals(b);
    } else {
      return serializedA == serializedB;
    }
  }

  private static bool compareClassWithObject(T a, Object b) @trusted nothrow @nogc {
    if (a is null && b is null) {
      return true;
    }
    if (a is null || b is null) {
      return false;
    }
    return a.opEquals(b);
  }

  /// Checks if this value is less than another EquableValue.
  bool isLessThan(EquableValue otherEquable) @trusted nothrow @nogc {
    static if (__traits(compiles, value < value)) {
      auto other = cast(ObjectEquable) otherEquable;

      if(other !is null) {
        return value < other.value;
      }

      return false;
    } else {
      return false;
    }
  }

  /// Returns the serialized string representation.
  string getSerialized() @safe nothrow @nogc {
    return serialized;
  }

  /// Returns a generalized version for cross-type comparison.
  /// Returns self - cross-type comparison uses getSerialized().
  EquableValue generalize() @safe nothrow @nogc {
    return this;
  }

  /// Returns the underlying value as Object if T is a class, null otherwise.
  Object getObjectValue() @trusted nothrow @nogc {
    static if (is(T == class)) {
      return cast(Object) value;
    } else {
      return null;
    }
  }

  /// Converts this value to an array of EquableValues.
  EquableValue[] toArray() @trusted nothrow {
    static if(__traits(hasMember, T, "byValue") && !__traits(hasMember, T, "byKeyValue")) {
      try {
        return value.byValue.map!(a => a.equableValue(SerializerRegistry.instance.serialize(a))).array;
      } catch(Exception) {}
    }

    return [ this ];
  }

  /// Returns the serialized string representation.
  override string toString() @safe nothrow @nogc {
    return serialized;
  }

  /// Comparison operator override.
  override int opCmp(Object o) @trusted nothrow @nogc {
    return -1;
  }
}

@("an object with byValue returns an array with all elements")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  class TestObject {
    auto byValue() {
      auto items = [1, 2];
      return items.inputRangeObject;
    }
  }

  auto value = equableValue(new TestObject(), "[1, 2]").toArray;
  assert(value.length == 2, "invalid length");
  assert(value[0].getSerialized == "1", value[0].getSerialized.idup ~ " != 1");
  assert(value[1].getSerialized == "2", value[1].getSerialized.idup ~ " != 2");
}

@("isLessThan returns true when value is less than other")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto value1 = equableValue(5, "5");
  auto value2 = equableValue(10, "10");

  assert(value1.isLessThan(value2) == true);
  assert(value2.isLessThan(value1) == false);
}

@("isLessThan returns false when values are equal")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto value1 = equableValue(5, "5");
  auto value2 = equableValue(5, "5");

  assert(value1.isLessThan(value2) == false);
}

@("isLessThan works with floating point numbers")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto value1 = equableValue(3.14, "3.14");
  auto value2 = equableValue(3.15, "3.15");

  assert(value1.isLessThan(value2) == true);
  assert(value2.isLessThan(value1) == false);
}

@("isLessThan returns false for arrays")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  auto value1 = equableValue([1, 2, 3], "[1, 2, 3]");
  auto value2 = equableValue([4, 5, 6], "[4, 5, 6]");

  assert(value1.isLessThan(value2) == false);
}

/// An EquableValue wrapper for array types.
/// Provides element-wise comparison capabilities.
class ArrayEquable(U: T[], T) : EquableValue {
  private {
    T[] values;
    string serialized;
  }

  /// Constructs an ArrayEquable wrapping the given array.
  this(T[] values, string serialized) @safe nothrow {
    this.values = values;
    this.serialized = serialized;
  }

  /// Checks equality with another EquableValue by comparing serialized forms.
  bool isEqualTo(EquableValue otherEquable) @trusted nothrow @nogc {
    auto other = cast(ArrayEquable!U) otherEquable;

    if(other is null) {
      return serialized == otherEquable.getSerialized;
    }

    return serialized == other.serialized;
  }

  /// Arrays do not support less-than comparison, always returns false.
  bool isLessThan(EquableValue otherEquable) @safe nothrow @nogc {
    return false;
  }

  /// Returns the serialized string representation.
  string getSerialized() @safe nothrow @nogc {
    return serialized;
  }

  /// Converts each array element to an EquableValue.
  EquableValue[] toArray() @trusted nothrow {
    static if(is(T == void)) {
      return [];
    } else {
      try {
        auto newList = values.map!(a => equableValue(a, SerializerRegistry.instance.niceValue(a))).array;

        return cast(EquableValue[]) newList;
      } catch(Exception) {
        return [];
      }
    }
  }

  /// Arrays are already generalized, returns self.
  EquableValue generalize() @safe nothrow @nogc {
    return this;
  }

  /// Arrays are not Objects, returns null.
  Object getObjectValue() @safe nothrow @nogc {
    return null;
  }

  /// Returns the serialized string representation.
  override string toString() @safe nothrow @nogc {
    return serialized;
  }
}

/// An EquableValue wrapper for associative array types.
/// Sorts keys for consistent comparison and inherits from ArrayEquable.
class AssocArrayEquable(U: T[V], T, V) : ArrayEquable!(string[], string) {
  /// Constructs an AssocArrayEquable, sorting entries by key.
  this(T[V] values, string serialized) {
    auto sortedKeys = values.keys.sort;

    auto sortedValues = sortedKeys
      .map!(a => SerializerRegistry.instance.niceValue(a) ~ `: ` ~ SerializerRegistry.instance.niceValue(values[a]))
      .array;

    super(sortedValues, serialized);
  }
}
