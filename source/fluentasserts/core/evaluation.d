module fluentasserts.core.evaluation;

import std.datetime;
import std.typecons;
import std.traits;
import std.conv;
import std.range;
import std.array;
import std.algorithm : map, sort;

import fluentasserts.core.serializers;
import fluentasserts.core.results;
import fluentasserts.core.base : TestException;

///
struct ValueEvaluation {
  /// The exception thrown during evaluation
  Throwable throwable;

  /// Time needed to evaluate the value
  Duration duration;

  /// Serialized value as string
  string strValue;

  /// Proxy object holding the evaluated value to help doing better comparisions
  EquableValue proxyValue;

  /// Human readable value
  string niceValue;

  /// The name of the type before it was converted to string
  string[] typeNames;

  /// Other info about the value
  string[string] meta;

  /// The file name contining the evaluated value
  string fileName;

  /// The line number of the evaluated value
  size_t line;

  /// a custom text to be prepended to the value
  string prependText;

  string typeName() @safe nothrow {
    if(typeNames.length == 0) {
      return "unknown";
    }

    return typeNames[0];
  }
}

///
class Evaluation {
  /// The id of the current evaluation
  size_t id;

  /// The value that will be validated
  ValueEvaluation currentValue;

  /// The expected value that we will use to perform the comparison
  ValueEvaluation expectedValue;

  /// The operation name
  string operationName;

  /// True if the operation result needs to be negated to have a successful result
  bool isNegated;

  /// The nice message printed to the user
  MessageResult message;

  /// The source code where the assert is located
  SourceResult source;

  /// Results generated during evaluation
  IResult[] results;

  /// The throwable generated by the evaluation
  Throwable throwable;

  /// True when the evaluation is done
  bool isEvaluated;
}

///
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isInputRange!T && !isArray!T && !isAssociativeArray!T) {
  return evaluate(testData.array, file, line, prependText);
}

///
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(!isInputRange!T || isArray!T || isAssociativeArray!T) {
  auto begin = Clock.currTime;
  alias Result = Tuple!(T, "value", ValueEvaluation, "evaluation");

  try {
    auto value = testData;
    alias TT = typeof(value);

    static if(isCallable!T) {
      if(value !is null) {
        begin = Clock.currTime;
        value();
      }
    }

    auto duration = Clock.currTime - begin;
    auto serializedValue = SerializerRegistry.instance.serialize(value);
    auto niceValue = SerializerRegistry.instance.niceValue(value);

    auto valueEvaluation = ValueEvaluation(null, duration, serializedValue, equableValue(value, niceValue), niceValue, extractTypes!TT);
    valueEvaluation.fileName = file;
    valueEvaluation.line = line;
    valueEvaluation.prependText = prependText;

    return Result(value, valueEvaluation);
  } catch(Throwable t) {
    T result;

    static if(isCallable!T) {
      result = testData;
    }

    auto valueEvaluation = ValueEvaluation(t, Clock.currTime - begin, result.to!string, equableValue(result, result.to!string), result.to!string, extractTypes!T);
    valueEvaluation.fileName = file;
    valueEvaluation.line = line;
    valueEvaluation.prependText = prependText;

    return Result(result, valueEvaluation);
  }
}

@("evaluate captures an exception from a lazy value")
unittest {
  int value() {
    throw new Exception("message");
  }

  auto result = evaluate(value);

  assert(result.evaluation.throwable !is null);
  assert(result.evaluation.throwable.msg == "message");
}

@("evaluate captures an exception from a callable")
unittest {
  void value() {
    throw new Exception("message");
  }

  auto result = evaluate(&value);

  assert(result.evaluation.throwable !is null);
  assert(result.evaluation.throwable.msg == "message");
}

string[] extractTypes(T)() if((!isArray!T && !isAssociativeArray!T) || isSomeString!T) {
  string[] types;

  types ~= unqualString!T;

  static if(is(T == class)) {
    static foreach(Type; BaseClassesTuple!T) {
      types ~= unqualString!Type;
    }
  }

  static if(is(T == interface) || is(T == class)) {
    static foreach(Type; InterfacesTuple!T) {
      types ~= unqualString!Type;
    }
  }

  return types;
}

string[] extractTypes(T: U[], U)() if(isArray!T && !isSomeString!T) {
  return extractTypes!(U).map!(a => a ~ "[]").array;
}

string[] extractTypes(T: U[K], U, K)() {
  string k = unqualString!(K);
  return extractTypes!(U).map!(a => a ~ "[" ~ k ~ "]").array;
}

@("extractTypes returns [string] for string")
unittest {
  auto result = extractTypes!string;
  assert(result == ["string"]);
}

@("extractTypes returns [string[]] for string[]")
unittest {
  auto result = extractTypes!(string[]);
  assert(result == ["string[]"]);
}

@("extractTypes returns [string[string]] for string[string]")
unittest {
  auto result = extractTypes!(string[string]);
  assert(result == ["string[string]"]);
}

@("extractTypes returns all types of a class")
unittest {
  interface I {}
  class T : I {}

  auto result = extractTypes!(T[]);

  assert(result[0] == "fluentasserts.core.evaluation.__unittest_L208_C1.T[]", `Expected: "fluentasserts.core.evaluation.__unittest_L208_C1.T[]" got "` ~ result[0] ~ `"`);
  assert(result[1] == "object.Object[]", `Expected: ` ~ result[1] );
  assert(result[2] ==  "fluentasserts.core.evaluation.__unittest_L208_C1.I[]", `Expected: ` ~ result[2] );
}

/// A proxy type that allows to compare the native values
interface EquableValue {
  @safe nothrow:
    bool isEqualTo(EquableValue value);
    bool isLessThan(EquableValue value);
    EquableValue[] toArray();
    string toString();
    EquableValue generalize();
    string getSerialized();
}

/// Wraps a value into equable value
EquableValue equableValue(T)(T value, string serialized) {
  static if(isArray!T && !isSomeString!T) {
    return new ArrayEquable!T(value, serialized);
  } else static if(isInputRange!T && !isSomeString!T) {
    return new ArrayEquable!T(value.array, serialized);
  } else static if(isAssociativeArray!T) {
    return new AssocArrayEquable!T(value, serialized);
  } else {
    return new ObjectEquable!T(value, serialized);
  }
}

///
class ObjectEquable(T) : EquableValue {
  private {
    T value;
    string serialized;
  }

  @trusted nothrow:
    this(T value, string serialized) {
      this.value = value;
      this.serialized = serialized;
    }

    bool isEqualTo(EquableValue otherEquable) {
      try {
        auto other = cast(ObjectEquable) otherEquable;

        if(other !is null) {
          return value == other.value;
        }

        auto generalized = otherEquable.generalize;

        static if(is(T == class)) {
          auto otherGeneralized = cast(ObjectEquable!Object) generalized;

          if(otherGeneralized !is null) {
            return value == otherGeneralized.value;
          }
        }

        return serialized == otherEquable.getSerialized;
      } catch(Exception) {
        return false;
      }
    }

    bool isLessThan(EquableValue otherEquable) {
      static if (__traits(compiles, value < value)) {
        try {
          auto other = cast(ObjectEquable) otherEquable;

          if(other !is null) {
            return value < other.value;
          }

          return false;
        } catch(Exception) {
          return false;
        }
      } else {
        return false;
      }
    }

    string getSerialized() {
      return serialized;
    }

    EquableValue generalize() {
        static if(is(T == class)) {
          auto obj = cast(Object) value;

          if(obj !is null) {
            return new ObjectEquable!Object(obj, serialized);
          }
        }

        return new ObjectEquable!string(serialized, serialized);
    }

    EquableValue[] toArray() {
      static if(__traits(hasMember, T, "byValue") && !__traits(hasMember, T, "byKeyValue")) {
        try {
          return value.byValue.map!(a => a.equableValue(SerializerRegistry.instance.serialize(a))).array;
        } catch(Exception) {}
      }

      return [ this ];
    }

    override string toString() {
      return "Equable." ~ serialized;
    }

    override int opCmp (Object o) {
      return -1;
    }
}

@("an object with byValue returns an array with all elements")
unittest {
  class TestObject {
    auto byValue() {
      auto items = [1, 2];
      return items.inputRangeObject;
    }
  }

  auto value = equableValue(new TestObject(), "[1, 2]").toArray;
  assert(value.length == 2, "invalid length");
  assert(value[0].toString == "Equable.1", value[0].toString ~ " != Equable.1");
  assert(value[1].toString == "Equable.2", value[1].toString ~ " != Equable.2");
}

@("isLessThan returns true when value is less than other")
unittest {
  auto value1 = equableValue(5, "5");
  auto value2 = equableValue(10, "10");

  assert(value1.isLessThan(value2) == true);
  assert(value2.isLessThan(value1) == false);
}

@("isLessThan returns false when values are equal")
unittest {
  auto value1 = equableValue(5, "5");
  auto value2 = equableValue(5, "5");

  assert(value1.isLessThan(value2) == false);
}

@("isLessThan works with floating point numbers")
unittest {
  auto value1 = equableValue(3.14, "3.14");
  auto value2 = equableValue(3.15, "3.15");

  assert(value1.isLessThan(value2) == true);
  assert(value2.isLessThan(value1) == false);
}

@("isLessThan returns false for arrays")
unittest {
  auto value1 = equableValue([1, 2, 3], "[1, 2, 3]");
  auto value2 = equableValue([4, 5, 6], "[4, 5, 6]");

  assert(value1.isLessThan(value2) == false);
}

///
class ArrayEquable(U: T[], T) : EquableValue {
  private {
    T[] values;
    string serialized;
  }

  @safe nothrow:
    this(T[] values, string serialized) {
      this.values = values;
      this.serialized = serialized;
    }

    bool isEqualTo(EquableValue otherEquable) {
      auto other = cast(ArrayEquable!U) otherEquable;

      if(other is null) {
        return false;
      }

      return serialized == other.serialized;
    }

    bool isLessThan(EquableValue otherEquable) {
      return false;
    }

    string getSerialized() {
      return serialized;
    }

    @trusted EquableValue[] toArray() {
      static if(is(T == void)) {
        return [];
      } else {
        try {
          auto newList = values.map!(a => equableValue(a, SerializerRegistry.instance.niceValue(a))).array;

          return cast(EquableValue[]) newList;
        } catch(Exception) {
          return [];
        }
      }
    }

    EquableValue generalize() {
      return this;
    }

    override string toString() {
      return serialized;
    }
}

///
class AssocArrayEquable(U: T[V], T, V) : ArrayEquable!(string[], string) {
  this(T[V] values, string serialized) {
    auto sortedKeys = values.keys.sort;

    auto sortedValues = sortedKeys
      .map!(a => SerializerRegistry.instance.niceValue(a) ~ `: ` ~ SerializerRegistry.instance.niceValue(values[a]))
      .array;

    super(sortedValues, serialized);
  }
}
