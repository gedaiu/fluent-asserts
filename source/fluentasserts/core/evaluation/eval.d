/// Evaluation logic for fluent-asserts.
/// Provides the Evaluation struct and evaluate functions for capturing assertion state.
module fluentasserts.core.evaluation.eval;

import std.datetime;
import std.traits;
import std.array;
import std.range;
import std.algorithm : move;

import core.memory : GC;

import fluentasserts.core.memory.heapstring : toHeapString, HeapString;
import fluentasserts.core.memory.process : getNonGCMemory;
import fluentasserts.core.conversion.tonumeric : toNumeric;
import fluentasserts.core.config : config = FluentAssertsConfig, OutputFormat;
import fluentasserts.core.evaluation.value;
import fluentasserts.core.evaluation.types;
import fluentasserts.core.evaluation.equable;
import fluentasserts.core.evaluation.constraints;
import fluentasserts.results.serializers.heap_registry : HeapSerializerRegistry;
import fluentasserts.results.source.result : SourceResult;
import fluentasserts.results.asserts : AssertResult;
import fluentasserts.results.printer : ResultPrinter, StringResultPrinter;

version(unittest) {
  import fluentasserts.core.lifecycle;
}

/// Holds the complete state of an assertion evaluation.
/// Contains both the actual and expected values, operation metadata,
/// source location, and the assertion result.
struct Evaluation {
  /// The id of the current evaluation
  size_t id;

  /// The value that will be validated
  ValueEvaluation currentValue;

  /// The expected value that we will use to perform the comparison
  ValueEvaluation expectedValue;

  /// The operation names (stored as array, joined on access)
  private {
    HeapString[config.buffers.maxOperationNames] _operationNames;
    size_t _operationCount;
  }

  /// True if the operation result needs to be negated to have a successful result
  bool isNegated;

  /// Source location data stored as struct
  SourceResult source;

  /// The throwable generated by the evaluation
  Throwable throwable;

  /// True when the evaluation is done
  bool isEvaluated;

  /// Result of the assertion stored as struct
  AssertResult result;

  /// Disable postblit - use copy constructor instead
  @disable this(this);

  /// Copy constructor - creates a deep copy from the source.
  this(ref return scope const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Assignment operator - creates a deep copy from the source.
  void opAssign(ref const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Returns the operation name by joining stored parts with "."
  string operationName() nothrow @safe {
    if (_operationCount == 0) {
      return "";
    }

    if (_operationCount == 1) {
      return _operationNames[0][].idup;
    }

    Appender!string result;
    foreach (i; 0 .. _operationCount) {
      if (i > 0) result.put(".");
      result.put(_operationNames[i][]);
    }

    return result[];
  }

  /// Adds an operation name to the chain
  void addOperationName(string name) nothrow @safe @nogc {
    if (_operationCount < _operationNames.length) {
      auto heapName = HeapString.create(name.length);
      heapName.put(name);
      _operationNames[_operationCount++] = heapName;
    }
  }

  /// Convenience accessors for backwards compatibility
  string sourceFile() nothrow @safe @nogc { return source.file; }
  size_t sourceLine() nothrow @safe @nogc { return source.line; }

  /// Checks if there is an assertion result with content.
  /// Returns: true if the result has expected/actual values, diff, or extra/missing items.
  bool hasResult() nothrow @safe @nogc {
    return result.hasContent();
  }

  /// Records a failed assertion with expected prefix and value.
  /// Automatically handles negation and sets actual from currentValue.niceValue.
  /// Params:
  ///   prefix = The prefix for expected (e.g., "greater than ")
  ///   value = The value part (e.g., "5")
  ///   negatedPrefix = The prefix to use when negated (e.g., "less than or equal to ")
  void fail(const(char)[] prefix, const(char)[] value, const(char)[] negatedPrefix = null) nothrow @safe @nogc {
    if (isNegated && negatedPrefix !is null) {
      result.expected.put(negatedPrefix);
    } else if (isNegated) {
      result.expected.put("not ");
      result.expected.put(prefix);
    } else {
      result.expected.put(prefix);
    }

    result.expected.put(value);
    result.negated = isNegated;

    if (!currentValue.niceValue.empty) {
      result.actual.put(currentValue.niceValue[]);
    } else {
      result.actual.put(currentValue.strValue[]);
    }
  }

  /// Checks a condition and records failure if needed.
  /// Handles negation automatically.
  /// Params:
  ///   condition = The assertion condition (true = pass, false = fail)
  ///   prefix = The prefix for expected (e.g., "greater than ")
  ///   value = The value part (e.g., "5")
  ///   negatedPrefix = The prefix to use when negated (optional)
  /// Returns: true if the assertion passed, false if it failed
  bool check(bool condition, const(char)[] prefix, const(char)[] value, const(char)[] negatedPrefix = null) nothrow @safe @nogc {
    bool passed = isNegated ? !condition : condition;

    if (passed) {
      return true;
    }

    fail(prefix, value, negatedPrefix);
    return false;
  }

  /// Checks a condition and sets expected only (caller sets actual).
  /// Returns: true if the assertion passed, false if it failed
  bool checkCustomActual(bool condition, const(char)[] expected, const(char)[] negatedExpected) nothrow @safe @nogc {
    bool passed = isNegated ? !condition : condition;

    if (passed) {
      return true;
    }

    result.expected.put(isNegated ? negatedExpected : expected);
    result.negated = isNegated;
    return false;
  }

  /// Reports a conversion error with the expected type name.
  /// Sets expected to "valid {typeName} values" and actual to "conversion error".
  void conversionError(const(char)[] typeName) nothrow @safe @nogc {
    result.expected.put("valid ");
    result.expected.put(typeName);
    result.expected.put(" values");
    result.actual.put("conversion error");
  }

  /// Parses Duration values from current and expected string values.
  /// Returns: true if parsing succeeded, false if conversion error was reported.
  bool parseDurations(out Duration currentDur, out Duration expectedDur) nothrow @safe @nogc {
    auto expected = toNumeric!ulong(expectedValue.strValue);
    auto current = toNumeric!ulong(currentValue.strValue);

    if (!expected.success || !current.success) {
      conversionError("Duration");
      return false;
    }

    expectedDur = dur!"nsecs"(expected.value);
    currentDur = dur!"nsecs"(current.value);
    return true;
  }

  /// Parses SysTime values from current and expected string values.
  /// Returns: true if parsing succeeded, false if conversion error was reported.
  bool parseSysTimes(out SysTime currentTime, out SysTime expectedTime) nothrow @safe {
    try {
      expectedTime = SysTime.fromISOExtString(expectedValue.strValue[]);
      currentTime = SysTime.fromISOExtString(currentValue.strValue[]);
      return true;
    } catch (Exception e) {
      conversionError("SysTime");
      return false;
    }
  }

  /// Reports a string prefix/suffix check failure with proper message formatting.
  /// Params:
  ///   matches = whether the string matches the expected prefix/suffix
  ///   positiveVerb = verb for positive case (e.g., "start with", "end with")
  ///   negativeVerb = verb for negative case (e.g., "starts with", "ends with")
  void reportStringCheck(bool matches, const(char)[] positiveVerb, const(char)[] negativeVerb) nothrow @safe @nogc {
    bool failed = isNegated ? matches : !matches;

    if (!failed) {
      return;
    }

    result.addText(" ");
    result.addValue(currentValue.strValue[]);
    result.addText(isNegated ? " " : " does not ");
    result.addText(negativeVerb);
    result.addText(" ");
    result.addValue(expectedValue.strValue[]);

    if (isNegated) {
      result.expected.put("not to ");
    } else {
      result.expected.put("to ");
    }
    result.expected.put(positiveVerb);
    result.expected.put(" ");
    result.expected.put(expectedValue.strValue[]);
    result.actual.put(currentValue.strValue[]);
    result.negated = isNegated;
  }

  /// Prints the assertion result using the provided printer.
  /// Params:
  ///   printer = The ResultPrinter to use for output formatting
  void printResult(ResultPrinter printer) @safe nothrow {
    if (!isEvaluated) {
      printer.primary("Evaluation not completed.");
      return;
    }

    if (!result.hasContent()) {
      printer.primary("Successful result.");
      return;
    }

    final switch (config.output.format) {
      case OutputFormat.verbose:
        printVerbose(printer);
        break;
      case OutputFormat.compact:
        printCompact(printer);
        break;
      case OutputFormat.tap:
        printTap(printer);
        break;
    }
  }

  private void printVerbose(ResultPrinter printer) @safe nothrow {
    printer.info("ASSERTION FAILED: ");

    foreach(ref message; result.messages) {
      printer.print(message);
    }

    printer.newLine;
    printer.info("OPERATION: ");

    if(isNegated) {
      printer.primary("not ");
    }

    printer.primary(operationName);
    printer.newLine;

    // Issue #79: Print context data if present
    if (result.hasContext) {
      printer.newLine;
      printer.info("CONTEXT:");
      printer.newLine;
      foreach (i; 0 .. result.contextCount) {
        printer.primary("  ");
        printer.primary(result.contextKey(i).idup);
        printer.primary(" = ");
        printer.primary(result.contextValue(i).idup);
        printer.newLine;
      }
      if (result.hasContextOverflow) {
        printer.danger("  (additional context entries were dropped)");
        printer.newLine;
      }
    }

    printer.newLine;

    printer.info("  ACTUAL: ");
    printer.primary("<");
    printer.primary(currentValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.actual[].idup);
    printer.newLine;

    printer.info("EXPECTED: ");
    printer.primary("<");
    printer.primary(expectedValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.expected[].idup);
    printer.newLine;

    source.print(printer);
  }

  private void printCompact(ResultPrinter printer) @safe nothrow {
    import std.conv : to;

    printer.danger("FAIL: ");

    foreach (ref message; result.messages) {
      printer.print(message);
    }

    // Issue #79: Print context data if present
    if (result.hasContext) {
      printer.primary(" | context: ");
      foreach (i; 0 .. result.contextCount) {
        if (i > 0) {
          printer.primary(", ");
        }
        printer.primary(result.contextKey(i).idup);
        printer.primary("=");
        printer.primary(result.contextValue(i).idup);
      }
      if (result.hasContextOverflow) {
        printer.primary(", ...(truncated)");
      }
    }

    printer.primary(" | actual=");
    printer.primary(result.actual[].idup);
    printer.primary(" expected=");
    printer.primary(result.expected[].idup);
    printer.primary(" | ");
    printer.primary(source.file);
    printer.primary(":");
    printer.primary(source.line.to!string);
    printer.newLine;
  }

  private void printTap(ResultPrinter printer) @safe nothrow {
    import std.conv : to;

    printer.danger("not ok ");
    printer.primary("- ");

    foreach (ref message; result.messages) {
      printer.print(message);
    }

    printer.newLine;
    printer.primary("  ---");
    printer.newLine;

    // Issue #79: Print context data if present
    if (result.hasContext) {
      printer.primary("  context:");
      printer.newLine;
      foreach (i; 0 .. result.contextCount) {
        printer.primary("    ");
        printer.primary(result.contextKey(i).idup);
        printer.primary(": ");
        printer.primary(result.contextValue(i).idup);
        printer.newLine;
      }
      if (result.hasContextOverflow) {
        printer.primary("    # additional context entries were dropped");
        printer.newLine;
      }
    }

    printer.primary("  actual: ");
    printer.primary(result.actual[].idup);
    printer.newLine;
    printer.primary("  expected: ");
    printer.primary(result.expected[].idup);
    printer.newLine;
    printer.primary("  at: ");
    printer.primary(source.file);
    printer.primary(":");
    printer.primary(source.line.to!string);
    printer.newLine;
    printer.primary("  ...");
    printer.newLine;
  }

  /// Converts the evaluation to a formatted string for display.
  /// Returns: A string representation of the evaluation result.
  string toString() @safe nothrow {
    import std.string : format;

    auto printer = new StringResultPrinter();
    printResult(printer);
    return printer.toString();
  }
}

/// Populates a ValueEvaluation with common fields.
void populateEvaluation(T)(
  ref ValueEvaluation eval,
  T value,
  Duration duration,
  size_t gcMemoryUsed,
  size_t nonGCMemoryUsed,
  Throwable throwable,
  string file,
  size_t line,
  string prependText
) @trusted {
  import std.traits : Unqual;

  auto serializedValue = HeapSerializerRegistry.instance.serialize(value);
  auto niceValueStr = HeapSerializerRegistry.instance.niceValue(value);

  eval.throwable = throwable;
  eval.duration = duration;
  eval.gcMemoryUsed = gcMemoryUsed;
  eval.nonGCMemoryUsed = nonGCMemoryUsed;
  eval.strValue = serializedValue;
  eval.proxyValue = equableValue(value, niceValueStr);
  eval.niceValue = niceValueStr;
  eval.typeNames = extractTypes!T;
  eval.fileName = toHeapString(file);
  eval.line = line;
  eval.prependText = toHeapString(prependText);
}


/// Measures memory usage of a callable value.
/// Returns: tuple of (gcMemoryUsed, nonGCMemoryUsed, newBeginTime)
/// Note: Non-GC memory measurement uses process-wide metrics which may be
/// affected by other threads during parallel test execution.
auto measureCallable(T)(T value, SysTime begin) @trusted {
  struct MeasureResult {
    size_t gcMemoryUsed;
    size_t nonGCMemoryUsed;
    SysTime newBegin;
  }

  MeasureResult r;
  r.newBegin = begin;

  static if (isCallable!T) {
    if (value is null) {
      return r;
    }

    r.newBegin = Clock.currTime;

    r.nonGCMemoryUsed = getNonGCMemory();
    auto gcBefore = GC.allocatedInCurrentThread();
    cast(void) value();
    r.gcMemoryUsed = GC.allocatedInCurrentThread() - gcBefore;
    r.nonGCMemoryUsed = getNonGCMemory() - r.nonGCMemoryUsed;
  }

  return r;
}

/// Evaluates a lazy input range value and captures the result.
/// Converts the range to an array and delegates to the primary evaluate function.
/// Params:
///   testData = The lazy value to evaluate
///   file = Source file (auto-captured)
///   line = Source line (auto-captured)
///   prependText = Optional text to prepend to the value display
/// Returns: An EvaluationResult containing the evaluated value and its ValueEvaluation.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isNonArrayRange!T) {
  import std.range : array;
  return evaluate(testData.array, file, line, prependText);
}

/// Evaluates a lazy value and captures the result along with timing and exception info.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isNotRangeOrIsCollection!T) {
  GC.disable();
  scope(exit) GC.enable();

  auto begin = Clock.currTime;
  alias Result = EvaluationResult!T;

  try {
    auto value = testData;
    auto measured = measureCallable(value, begin);

    Result result;
    result.value = value;
    populateEvaluation(result.evaluation, value, Clock.currTime - measured.newBegin, measured.gcMemoryUsed, measured.nonGCMemoryUsed, null, file, line, prependText);
    return move(result);
  } catch (Throwable t) {
    T resultValue;
    static if (isCallable!T) {
      resultValue = testData;
    }

    Result result;
    result.value = resultValue;
    populateEvaluation(result.evaluation, resultValue, Clock.currTime - begin, 0, 0, t, file, line, prependText);
    return move(result);
  }
}

/// Evaluates an object without GC tracking or duration measurement.
/// Lightweight version for object comparison that skips performance metrics.
/// Params:
///   obj = The object to evaluate
///   file = Source file (auto-captured)
///   line = Source line (auto-captured)
///   prependText = Optional text to prepend to the value display
/// Returns: An EvaluationResult containing the object and its ValueEvaluation.
auto evaluateObject(T)(T obj, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(is(Unqual!T : Object)) {
  import std.traits : Unqual;
  alias Result = EvaluationResult!T;

  auto serializedValue = HeapSerializerRegistry.instance.serialize(obj);
  auto niceValueStr = HeapSerializerRegistry.instance.niceValue(obj);

  Result result;
  result.value = obj;
  result.evaluation.throwable = null;
  result.evaluation.duration = Duration.zero;
  result.evaluation.gcMemoryUsed = 0;
  result.evaluation.nonGCMemoryUsed = 0;
  result.evaluation.strValue = serializedValue;
  result.evaluation.proxyValue = equableValue(obj, niceValueStr);
  result.evaluation.niceValue = niceValueStr;
  result.evaluation.typeNames = extractTypes!T;
  result.evaluation.fileName = toHeapString(file);
  result.evaluation.line = line;
  result.evaluation.prependText = toHeapString(prependText);

  return move(result);
}

@("evaluate captures an exception from a lazy value")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  int value() {
    throw new Exception("message");
  }

  auto result = evaluate(value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

@("evaluate captures an exception from a callable")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  void value() {
    throw new Exception("message");
  }

  auto result = evaluate(&value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

@("evaluateObject creates evaluation for object without GC tracking")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {
    int x;
    this(int x) { this.x = x; }
  }

  auto obj = new TestClass(42);
  auto result = evaluateObject(obj);

  assert(result.value is obj);
  assert(result.evaluation.gcMemoryUsed == 0);
  assert(result.evaluation.nonGCMemoryUsed == 0);
  assert(result.evaluation.duration == Duration.zero);
  assert(!result.evaluation.proxyValue.isNull());
  assert(result.evaluation.proxyValue.getObjectRef() is cast(Object) obj);
}

@("evaluateObject creates evaluation for null object")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {}
  TestClass obj = null;

  auto result = evaluateObject(obj);

  assert(result.value is null);
  assert(result.evaluation.proxyValue.getObjectRef() is null);
  assert(result.evaluation.gcMemoryUsed == 0);
}

// Issue #98: opEquals should be honored when asserting equality
@("evaluateObject sets proxyValue with object reference for opEquals comparison")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {
    int value;
    this(int v) { value = v; }

    override bool opEquals(Object other) {
      auto o = cast(TestClass) other;
      if (o is null) {
        return false;
      }
      return value == o.value;
    }
  }

  auto obj1 = new TestClass(10);
  auto obj2 = new TestClass(10);

  auto result1 = evaluateObject(obj1);
  auto result2 = evaluateObject(obj2);

  assert(!result1.evaluation.proxyValue.isNull());
  assert(!result2.evaluation.proxyValue.isNull());
  // Now proxyValue uses opEquals via object references
  assert(result1.evaluation.proxyValue.isEqualTo(result2.evaluation.proxyValue));
}

// Issue #90: std.container.array Range types have @system destructors
// The evaluate function is @trusted so it can handle ranges with @system destructors
@("issue #90: evaluate works with std.container.array ranges")
@system unittest {
  import std.container.array : Array;

  auto arr = Array!int();
  arr.insertBack(1);
  arr.insertBack(2);
  arr.insertBack(3);

  // This should compile and work - the range has a @system destructor
  // but evaluate is @trusted so it can handle it
  auto result = evaluate(arr[]);

  assert(result.evaluation.strValue[] == "[1, 2, 3]",
    "Expected '[1, 2, 3]', got '" ~ result.evaluation.strValue[].idup ~ "'");
}

// Issue #88: std.range.interfaces.InputRange should be treated as a range
// The isNonArrayRange constraint correctly identifies InputRange interfaces
@("issue #88: evaluate works with std.range.interfaces.InputRange")
unittest {
  import std.range.interfaces : InputRange, inputRangeObject;

  auto arr = [1, 2, 3];
  InputRange!int ir = inputRangeObject(arr);

  // InputRange is detected as isNonArrayRange and converted to array
  auto result = evaluate(ir);

  assert(result.evaluation.strValue[] == "[1, 2, 3]",
    "Expected '[1, 2, 3]', got '" ~ result.evaluation.strValue[].idup ~ "'");
}
