/// Evaluation logic for fluent-asserts.
/// Provides the Evaluation struct and evaluate functions for capturing assertion state.
module fluentasserts.core.evaluation.eval;

import std.datetime;
import std.traits;
import std.array;
import std.range;
import std.algorithm : move;

import core.memory : GC;

import fluentasserts.core.memory : getNonGCMemory, toHeapString, HeapString;
import fluentasserts.core.evaluation.value;
import fluentasserts.core.evaluation.types;
import fluentasserts.core.evaluation.equable;
import fluentasserts.core.evaluation.constraints;
import fluentasserts.results.serializers : SerializerRegistry;
import fluentasserts.results.source : SourceResult;
import fluentasserts.results.asserts : AssertResult;
import fluentasserts.results.printer : ResultPrinter, StringResultPrinter;

version(unittest) {
  import fluentasserts.core.lifecycle;
}

/// Holds the complete state of an assertion evaluation.
/// Contains both the actual and expected values, operation metadata,
/// source location, and the assertion result.
struct Evaluation {
  /// The id of the current evaluation
  size_t id;

  /// The value that will be validated
  ValueEvaluation currentValue;

  /// The expected value that we will use to perform the comparison
  ValueEvaluation expectedValue;

  /// The operation names (stored as array, joined on access)
  private {
    HeapString[8] _operationNames;
    size_t _operationCount;
  }

  /// True if the operation result needs to be negated to have a successful result
  bool isNegated;

  /// Source location data stored as struct
  SourceResult source;

  /// The throwable generated by the evaluation
  Throwable throwable;

  /// True when the evaluation is done
  bool isEvaluated;

  /// Result of the assertion stored as struct
  AssertResult result;

  /// Disable postblit - use copy constructor instead
  @disable this(this);

  /// Copy constructor - creates a deep copy from the source.
  this(ref return scope const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Assignment operator - creates a deep copy from the source.
  void opAssign(ref const Evaluation rhs) @trusted nothrow {
    id = rhs.id;
    currentValue = rhs.currentValue;
    expectedValue = rhs.expectedValue;

    _operationCount = rhs._operationCount;
    foreach (i; 0 .. _operationCount) {
      _operationNames[i] = rhs._operationNames[i];
    }

    isNegated = rhs.isNegated;
    source = rhs.source;
    throwable = cast(Throwable) rhs.throwable;
    isEvaluated = rhs.isEvaluated;
    result = rhs.result;
  }

  /// Returns the operation name by joining stored parts with "."
  string operationName() nothrow @safe {
    if (_operationCount == 0) {
      return "";
    }

    if (_operationCount == 1) {
      return _operationNames[0][].idup;
    }

    Appender!string result;
    foreach (i; 0 .. _operationCount) {
      if (i > 0) result.put(".");
      result.put(_operationNames[i][]);
    }

    return result[];
  }

  /// Adds an operation name to the chain
  void addOperationName(string name) nothrow @safe @nogc {
    if (_operationCount < _operationNames.length) {
      auto heapName = HeapString.create(name.length);
      heapName.put(name);
      _operationNames[_operationCount++] = heapName;
    }
  }

  /// Convenience accessors for backwards compatibility
  string sourceFile() nothrow @safe @nogc { return source.file; }
  size_t sourceLine() nothrow @safe @nogc { return source.line; }

  /// Checks if there is an assertion result with content.
  /// Returns: true if the result has expected/actual values, diff, or extra/missing items.
  bool hasResult() nothrow @safe @nogc {
    return result.hasContent();
  }

  /// Prints the assertion result using the provided printer.
  /// Params:
  ///   printer = The ResultPrinter to use for output formatting
  void printResult(ResultPrinter printer) @safe nothrow {
    if(!isEvaluated) {
      printer.primary("Evaluation not completed.");
      return;
    }

    if(!result.hasContent()) {
      printer.primary("Successful result.");
      return;
    }

    printer.info("ASSERTION FAILED: ");

    foreach(ref message; result.messages) {
      printer.print(message);
    }

    printer.newLine;
    printer.info("OPERATION: ");

    if(isNegated) {
      printer.primary("not ");
    }

    printer.primary(operationName);
    printer.newLine;
    printer.newLine;

    printer.info("  ACTUAL: ");
    printer.primary("<");
    printer.primary(currentValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.actual[].idup);
    printer.newLine;

    printer.info("EXPECTED: ");
    printer.primary("<");
    printer.primary(expectedValue.typeName.idup);
    printer.primary("> ");
    printer.primary(result.expected[].idup);
    printer.newLine;

    source.print(printer);
  }

  /// Converts the evaluation to a formatted string for display.
  /// Returns: A string representation of the evaluation result.
  string toString() @safe nothrow {
    import std.string : format;

    auto printer = new StringResultPrinter();
    printResult(printer);
    return printer.toString();
  }
}

/// Populates a ValueEvaluation with common fields.
void populateEvaluation(T)(
  ref ValueEvaluation eval,
  T value,
  Duration duration,
  size_t gcMemoryUsed,
  size_t nonGCMemoryUsed,
  Throwable throwable,
  string file,
  size_t line,
  string prependText
) @trusted {
  import std.traits : Unqual;

  auto serializedValue = SerializerRegistry.instance.serialize(value);
  auto niceValueStr = SerializerRegistry.instance.niceValue(value);

  eval.throwable = throwable;
  eval.duration = duration;
  eval.gcMemoryUsed = gcMemoryUsed;
  eval.nonGCMemoryUsed = nonGCMemoryUsed;
  eval.strValue = toHeapString(serializedValue);
  eval.proxyValue = equableValue(value, niceValueStr);
  eval.niceValue = toHeapString(niceValueStr);
  eval.typeNames = extractTypes!T;
  eval.fileName = toHeapString(file);
  eval.line = line;
  eval.prependText = toHeapString(prependText);
}

/// Measures memory usage of a callable value.
/// Returns: tuple of (gcMemoryUsed, nonGCMemoryUsed, newBeginTime)
auto measureCallable(T)(T value, SysTime begin) @trusted {
  struct MeasureResult {
    size_t gcMemoryUsed;
    size_t nonGCMemoryUsed;
    SysTime newBegin;
  }

  MeasureResult r;
  r.newBegin = begin;

  static if (isCallable!T) {
    if (value is null) {
      return r;
    }

    r.newBegin = Clock.currTime;
    r.nonGCMemoryUsed = getNonGCMemory();
    auto gcBefore = GC.allocatedInCurrentThread();
    cast(void) value();
    r.gcMemoryUsed = GC.allocatedInCurrentThread() - gcBefore;
    r.nonGCMemoryUsed = getNonGCMemory() - r.nonGCMemoryUsed;
  }

  return r;
}

/// Evaluates a lazy input range value and captures the result.
/// Converts the range to an array and delegates to the primary evaluate function.
/// Params:
///   testData = The lazy value to evaluate
///   file = Source file (auto-captured)
///   line = Source line (auto-captured)
///   prependText = Optional text to prepend to the value display
/// Returns: An EvaluationResult containing the evaluated value and its ValueEvaluation.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isNonArrayRange!T) {
  import std.range : array;
  return evaluate(testData.array, file, line, prependText);
}

/// Evaluates a lazy value and captures the result along with timing and exception info.
auto evaluate(T)(lazy T testData, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(isNotRangeOrIsCollection!T) {
  GC.collect();
  GC.minimize();
  GC.disable();
  scope(exit) GC.enable();

  auto begin = Clock.currTime;
  alias Result = EvaluationResult!T;

  try {
    auto value = testData;
    auto measured = measureCallable(value, begin);

    Result result;
    result.value = value;
    populateEvaluation(result.evaluation, value, Clock.currTime - measured.newBegin, measured.gcMemoryUsed, measured.nonGCMemoryUsed, null, file, line, prependText);
    return move(result);
  } catch (Throwable t) {
    T resultValue;
    static if (isCallable!T) {
      resultValue = testData;
    }

    Result result;
    result.value = resultValue;
    populateEvaluation(result.evaluation, resultValue, Clock.currTime - begin, 0, 0, t, file, line, prependText);
    return move(result);
  }
}

/// Evaluates an object without GC tracking or duration measurement.
/// Lightweight version for object comparison that skips performance metrics.
/// Params:
///   obj = The object to evaluate
///   file = Source file (auto-captured)
///   line = Source line (auto-captured)
///   prependText = Optional text to prepend to the value display
/// Returns: An EvaluationResult containing the object and its ValueEvaluation.
auto evaluateObject(T)(T obj, const string file = __FILE__, const size_t line = __LINE__, string prependText = null) @trusted if(is(Unqual!T : Object)) {
  import std.traits : Unqual;
  alias Result = EvaluationResult!T;

  auto serializedValue = SerializerRegistry.instance.serialize(obj);
  auto niceValueStr = SerializerRegistry.instance.niceValue(obj);

  Result result;
  result.value = obj;
  result.evaluation.throwable = null;
  result.evaluation.duration = Duration.zero;
  result.evaluation.gcMemoryUsed = 0;
  result.evaluation.nonGCMemoryUsed = 0;
  result.evaluation.strValue = toHeapString(serializedValue);
  result.evaluation.proxyValue = equableValue(obj, niceValueStr);
  result.evaluation.niceValue = toHeapString(niceValueStr);
  result.evaluation.typeNames = extractTypes!T;
  result.evaluation.fileName = toHeapString(file);
  result.evaluation.line = line;
  result.evaluation.prependText = toHeapString(prependText);

  return move(result);
}

@("evaluate captures an exception from a lazy value")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  int value() {
    throw new Exception("message");
  }

  auto result = evaluate(value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

@("evaluate captures an exception from a callable")
unittest {
  Lifecycle.instance.disableFailureHandling = false;
  void value() {
    throw new Exception("message");
  }

  auto result = evaluate(&value);

  assert(result.evaluation.throwable !is null, "Expected throwable to be captured");
  assert(result.evaluation.throwable.msg == "message", "Expected msg 'message', got '" ~ result.evaluation.throwable.msg ~ "'");
}

@("evaluateObject creates evaluation for object without GC tracking")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {
    int x;
    this(int x) { this.x = x; }
  }

  auto obj = new TestClass(42);
  auto result = evaluateObject(obj);

  assert(result.value is obj);
  assert(result.evaluation.gcMemoryUsed == 0);
  assert(result.evaluation.nonGCMemoryUsed == 0);
  assert(result.evaluation.duration == Duration.zero);
  assert(!result.evaluation.proxyValue.isNull());
  assert(result.evaluation.proxyValue.getObjectRef() is cast(Object) obj);
}

@("evaluateObject creates evaluation for null object")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {}
  TestClass obj = null;

  auto result = evaluateObject(obj);

  assert(result.value is null);
  assert(result.evaluation.proxyValue.getObjectRef() is null);
  assert(result.evaluation.gcMemoryUsed == 0);
}

@("evaluateObject sets proxyValue with object reference for opEquals comparison")
unittest {
  Lifecycle.instance.disableFailureHandling = false;

  class TestClass {
    int value;
    this(int v) { value = v; }

    override bool opEquals(Object other) {
      auto o = cast(TestClass) other;
      if (o is null) {
        return false;
      }
      return value == o.value;
    }
  }

  auto obj1 = new TestClass(10);
  auto obj2 = new TestClass(10);

  auto result1 = evaluateObject(obj1);
  auto result2 = evaluateObject(obj2);

  assert(!result1.evaluation.proxyValue.isNull());
  assert(!result2.evaluation.proxyValue.isNull());
  // Now proxyValue uses opEquals via object references
  assert(result1.evaluation.proxyValue.isEqualTo(result2.evaluation.proxyValue));
}
